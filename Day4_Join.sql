
-- CONSTRAINT -- RULES FOR COLUMNS
    ---1.PRIMARY KEY 
    ---2.FOREIGN KEY

-- find out the first name and department name
-- use employees table and department table

SELECT FIRST_NAME,DEPARTMENT_NAME FROM EMPLOYEES 
INNER JOIN DEPARTMENTS ON DEPARTMENTS.DEPARTMENT_ID = EMPLOYEES.DEPARTMENT_ID;

-- above query just work but adding table name in front of column name all the time is not efficient
-- we can use alias to make this simpler

select e.first_name,d.department_name 
from employees e -- this is how we put alias for table
inner join departments d 
on e.department_id = d.department_id; 

-- get the first name and job title
-- use employees and jobs table

select e.first_name,j.job_title
from employees e
inner join jobs j 
on e.job_id = j.job_id; 

-- firstname, department name, city, country name, region name

select e.first_name, d.department_name, l.city, c.country_name, r.region_name 
from employees e
inner join departments d on e.department_id = d.department_id
inner join locations l on l.location_id = d.location_id
inner join countries c on l.country_id = c.country_id
inner join regions r on c.region_id = r.region_id;


-- INNER JOIN 
/*
INNER JOIN WILL ONLY
RETURN THE DATA MATCH IN
BOTH TABLES,
ANYTHING DOES NOT MATCH
WILL NOT BE PART OF THE
RESULT
*/

SELECT e.FIRST_NAME , d.DEPARTMENT_NAME 
FROM EMPLOYEES e                -- THIS IS HOW YOU PUT ALIASE FOR TABLE 
INNER JOIN DEPARTMENTS d ON e.Department_Id = d.DEPARTMENT_ID ; 

-- the result of above query is 106 RATHER than 107 
-- because one employee does not have department 
SELECT * FROM EMPLOYEES 
WHERE DEPARTMENT_ID IS NULL ; 



--- LEFT OUTER JOIN 

--- WHICHEVER TABLE COMES FIRST , IT'S REFERRED AS LEFT TABLE 
--- WHICHEVER TABLE COMES AFTER , IT'S REFERRED AS RIGHT TABLE 

-- TASK GET ALL FIRST NAME AND DEPARTMENT 
-- INCLUDING THE EMPLOYEES WITHOUT DEPARTMENT 
SELECT e.FIRST_NAME , d.DEPARTMENT_NAME 
FROM EMPLOYEES e                -- THIS IS HOW YOU PUT ALIASE FOR TABLE 
LEFT OUTER JOIN DEPARTMENTS d ON e.Department_Id = d.DEPARTMENT_ID ; 

-- TASK GET ALL FIRST NAME AND DEPARTMENT 
-- INCLUDING THE DEPARTMENT WITHOUT ANY EMPLOYEE
SELECT e.FIRST_NAME , d.DEPARTMENT_NAME 
FROM EMPLOYEES e                -- THIS IS HOW YOU PUT ALIASE FOR TABLE 
RIGHT OUTER JOIN DEPARTMENTS d ON e.Department_Id = d.DEPARTMENT_ID ; 

-- TASK GET ALL FIRST NAME AND DEPARTMENT 
-- INCLUDING THE DEPARTMENT WITHOUT ANY EMPLOYEE
-- INCLUDING THE EMPLOYEE WITHOUT ANY DEPARTMENT 
SELECT e.FIRST_NAME , d.DEPARTMENT_NAME 
FROM EMPLOYEES e                -- THIS IS HOW YOU PUT ALIASE FOR TABLE 
FULL OUTER JOIN DEPARTMENTS d ON e.Department_Id = d.DEPARTMENT_ID ;



-- In order for SET Operators to work , 
-- Two tables or result of two query being used MUST HAVE 
-- - same exact column count 
-- - same exact column name 
-- - same exact column data type 

-- Unlike JOIN which require primary key and foreign key relationship, SET Operator must have above pre-requisite or it will not work at all !  
-- JOIN and SET Operators are two completely different concepts.


CREATE TABLE FIRST_TABLE AS (
    SELECT FIRST_NAME , SALARY FROM EMPLOYEES 
    WHERE SALARY BETWEEN 10500 AND 13000
    
) ORDER BY 2 ;  


CREATE TABLE SECOND_TABLE AS (
    SELECT FIRST_NAME , SALARY FROM EMPLOYEES 
    WHERE SALARY BETWEEN 12000 AND 24000
    
) ORDER BY 2 ;  

COMMIT ;


-- SET OPERATORS 
-- UNION ALL , UNION , MINUS , INTERSECT 


-----TEST YOU HAVE REQUIRED TABLES BY RUNNUNG BELOW-----
SELECT * FROM FIRST_TABLE;
SELECT * FROM SECOND_TABLE;


-- UNION ALL 
-- COMBINE THE RESULT OF 2 QUERY AND WILL NOT REMOVE DUPLICATE WILL NOT SORT BY FIRST COLUMN 
SELECT * FROM FIRST_TABLE 
UNION ALL 
SELECT * FROM SECOND_TABLE;


-- UNION  
-- COMBINE THE RESULT OF 2 QUERY AND WILL REMOVE DUPLICATE WILL SORT BY FIRST COLUMN 
-- DUPLICATE HERE MEANS ROW LEVEL DUPLICATION , 
--- IF 2 ROWS ARE DUPLICATE , ALL COLUMNS VALUE MUST BE THE SAME 
SELECT * FROM FIRST_TABLE 
UNION 
SELECT * FROM SECOND_TABLE  ; 

/*
FIRST_TABLE MINUS SECOND_TABLE
WILL REMOVE THOSE ROW FROM FIRST_TABLE
IF IT EXISTS IN SECOND_TABLE
*/
SELECT * FROM FIRST_TABLE 
MINUS 
SELECT * FROM SECOND_TABLE ; 

/*
SECOND_TABLE MINUS FIRST_TABLE
WILL REMOVE THOSE ROW FROM SECOND_TABLE
IF IT EXISTS IN FIRST_TABLE
*/
SELECT * FROM SECOND_TABLE 
MINUS 
SELECT * FROM FIRST_TABLE ; 

/*
SECOND_TABLE INTERSECT FIRST_TABLE
WILL ONLY RETURN COMMON ROWS FROM BOTH TABLE
*/
SELECT * FROM FIRST_TABLE 
INTERSECT 
SELECT * FROM SECOND_TABLE ; 


-- LIST 1  : APPLE , EGG , MILK , PINEAPPLE, BREAD
-- LIST 2  : MILK , BREAD , OIL , WALNUT

-- UNION ALL -->> APPLE , EGG , MILK , PINEAPPLE, BREAD , MILK , BREAD , OIL , WALNUT
-- UNION     -->> APPLE , BREAD , EGG, MILK, PINEAPPLE , OIL , WALNUT 


-- LIST 1  MINUS LIST 2 
 -- LIST 2 HERE IS NO-NO LIST 
  
  -- MINUS   --> APPLE , EGG , PINEAPPLE
  
-- LIST2 MINUS LIST 1 
  -- LIST 1 HERE IS NO-NO LIST 
    
  -- MINUS -->>   OIL , WALNUT 


 --- INTERSECT 
    -- LIST 1 INTERSECT LIST 2 
        --->> ONLY COMMON PART OF BOTH LIST  -->> MILK , BREAD


        -- FINAL HOUR PRACTICE

-- COMBINE WHAT WE LEARNED 


-- GET THE EMPLOYEE COUNT OF EACH DEPARTMENT 
-- THE RESULT SHOULD INCLUDE 2 COLUMNS : 
-- DEPARTMENT_NAME , EMPLOYEE_COUNT 

SELECT d.DEPARTMENT_NAME , COUNT(*) AS EMPLOYEE_COUNT
FROM EMPLOYEES e
INNER JOIN DEPARTMENTS d on e.DEPARTMENT_ID = d.DEPARTMENT_ID
GROUP BY d.DEPARTMENT_NAME
ORDER BY 2  -- ORDER BY MUST BE THE LAST LINE OF THE QUERY!!!!!!!!!!
;


-- ON TOP OF ABOVE QUERY 
-- ONLY LIST THOSE DEPARTMENT NAMES STARTED WITH A OR ended with ng
SELECT d.DEPARTMENT_NAME , COUNT(*) AS EMPLOYEE_COUNT
FROM EMPLOYEES e
INNER JOIN DEPARTMENTS d on e.DEPARTMENT_ID = d.DEPARTMENT_ID
GROUP BY d.DEPARTMENT_NAME
HAVING d.DEPARTMENT_NAME LIKE 'A%' OR d.DEPARTMENT_NAME LIKE '%ng'; 
--- IF YOU ARE USING COUNT(*) FOR CONDITION YOU CAN ONLY USE IT WITH HAVING 
-- IF YOUR CONDITION DOES NOT INVOLVE AGGREGATE YOU CAN FILTER DIRECTLY WITH WHERE 


-- SINCE WE ARE NOT USING COUNT(*) FOR CONDITION PART 
-- WE CAN DIRECTLY FILTER OUT THE RESULT FIRST 
-- THEN DO THE GROUPING 

SELECT d.DEPARTMENT_NAME , COUNT(*) AS EMPLOYEE_COUNT
FROM EMPLOYEES e
INNER JOIN DEPARTMENTS d on e.DEPARTMENT_ID = d.DEPARTMENT_ID
WHERE d.DEPARTMENT_NAME LIKE 'A%' OR d.DEPARTMENT_NAME LIKE '%ng'
GROUP BY d.DEPARTMENT_NAME  ; 

--- BY EXTENDING ABOVE QUERY , RETURN THE DEPARTMENT NAME WITH MORE THAN 5 EMPLOYEES 
SELECT d.DEPARTMENT_NAME , COUNT(*) AS EMPLOYEE_COUNT
FROM EMPLOYEES e
INNER JOIN DEPARTMENTS d on e.DEPARTMENT_ID = d.DEPARTMENT_ID
WHERE d.DEPARTMENT_NAME LIKE 'A%' OR d.DEPARTMENT_NAME LIKE '%ng'
GROUP BY d.DEPARTMENT_NAME  
HAVING COUNT(*) > 5 
; 

-- FIND OUT HOW MANY DEPARTMENT IN EACH COUNTRY
--- COUNTRIES -<COUNTRY_ID>--LOCATION --<LOCATION_ID>--  DEPARTMENT  
SELECT c.country_name , COUNT(d.department_name)
FROM DEPARTMENTS d 
INNER JOIN LOCATIONS l on d.LOCATION_ID = l.LOCATION_ID
INNER JOIN COUNTRIES c on l.COUNTRY_ID = c.COUNTRY_ID

GROUP BY c.COUNTRY_NAME

; 


-- FIND OUT HOW MANY DEPARTMENT IN EACH COUNTRY 
--- COUNTRIES -<COUNTRY_ID>--LOCATION --<LOCATION_ID>--  DEPARTMENT  
-- THE RESULT MUST INCLUDE ALL COUNTRIES WITHOUT CITY OR WITHOUT ANY DEPARTMENT IN
SELECT c.country_name , COUNT(d.department_name)
FROM DEPARTMENTS d 
RIGHT JOIN LOCATIONS l on d.LOCATION_ID = l.LOCATION_ID
RIGHT JOIN COUNTRIES c on l.COUNTRY_ID = c.COUNTRY_ID
GROUP BY c.COUNTRY_NAME
ORDER BY 2 DESC
;






